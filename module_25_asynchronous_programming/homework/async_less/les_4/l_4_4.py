# Конкурентное выполнение задач с помощью gather(ожидание завершения всех запросов)

import asyncio
import aiohttp

from module_25_asynchronous_programming.homework.async_less.util import async_timed, fetch_status


@async_timed()
async def main():
    urls = ["https://example.com" for _ in range(10)]
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_status(session, url) for url in urls]
        status_code = await asyncio.gather(*tasks)  # все объекты вернутся в том же порядке, в котором были переданы.
        print(status_code)


if __name__ == '__main__':
    asyncio.run(main())

"""
Функция gather имеет несколько недостатков. Первый мы уже упоминали – не так просто отменить задачи, 
если одна из них возбудила исключение. Представьте, что мы отправляем запросы одному сер- веру,
и если хотя бы один завершится неудачно, например из-за превышения лимита на частоту запросов, 
то остальные постигнет та же участь. В таком случае хотелось бы отменить запросы, чтобы освободить ресурсы, 
но это нелегко, потому что наши сопрограммы обернуты задачами и работают в фоновом режиме.
Второй недостаток  – необходимость дождаться завершения всех сопрограмм, прежде чем можно будет приступить к 
обработке результатов. Если мы хотим обрабатывать результаты по мере поступления, то возникает проблема. 
Например, если один запрос выполняется 100 мс, а другой 20 с, то придется ждать, ничего не делая, 20 с, 
прежде чем мы сможем обработать результаты первого запроса.
"""
