import asyncio
from asyncio.subprocess import Process


async def main():
    program = ['python3', 'l_13_4.py']
    process: Process = await asyncio.create_subprocess_exec(*program,
                                                            stdout=asyncio.subprocess.PIPE)
    print(f'Process pid is: {process.pid}')

    stdout, stderr = await process.communicate()
    print(stdout)
    print(stderr)
    print(f'Process returned: {process.returncode}')


asyncio.run(main())

"""
Выполнив эту программу, вы увидите, что весь вывод приложения печатается на консоли сразу (и один раз печатается `None`,
 потому что мы ничего не писали в стандартный вывод для ошибок). Под капотом `communicate` создает несколько задач, 
 которые постоянно читают стандартный вывод во внутренний буфер, избегая тем самым взаимоблокировки. 

Но хотя проблему взаимоблокировки мы решили, это решение имеет серьезный недостаток: мы теперь не можем интерактивно 
обрабатывать данные из стандартного вывода. Если требуется реагировать на данные, выводимые приложением 
(например, завершать работу или запускать новую задачу при получении определенного сообщения), 
то следует использовать `wait`, но при этом аккуратно читать из потокового читателя, чтобы избежать взаимоблокировки.

Еще один недостаток состоит в том, что `communicate` буферизует в памяти все данные из стандартного вывода и 
стандартного вывода для ошибок. Если подпроцесс порождает большой объем данных, то возникает риск нехватки памяти. 
Как преодолеть эти недостатки, мы увидим в следующем разделе.
"""