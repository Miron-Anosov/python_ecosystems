import asyncio
from asyncio.subprocess import Process


async def main():
    program = ['python3', 'l_13_4.py']
    process: Process = await asyncio.create_subprocess_exec(*program,
                                                            stdout=asyncio.subprocess.PIPE)
    print(f'Process pid is: {process.pid}')

    return_code = await process.wait()  # будет переполнен буфер вывода
    print(f'Process returned: {return_code}')


asyncio.run(main())

"""
Запустив эту программу, мы увидим напечатанный PID процесса, и больше ничего. Приложение зависает навсегда, завершить 
его можно только принудительно. Если в вашей системе такого не наблюдается, просто увеличьте число операций записи 
строки в буфер стандартного вывода — рано или поздно проблема проявится.

Такое простое приложение — откуда же взялась взаимоблокировка? Проблема связана с тем, как работает буфер 
потокового читателя. Когда буфер заполнен, любая попытка записать в него еще что-то приводит к блокированию программы 
до освобождения места в буфере. Хотя буфер читателя полон, наш процесс не оставляет попыток впихнуть в него все свои 
данные. Таким образом, завершение процесса оказывается зависимым от разблокировки потокового читателя, но этого никогда 
не произойдет, потому что мы не освобождаем место в буфере. 
Налицо циклическая зависимость, а следовательно, взаимоблокировка.
"""