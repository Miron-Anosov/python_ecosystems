import asyncio
from asyncio.subprocess import Process


async def main():
    process: Process = await asyncio.create_subprocess_exec('ls', '-l')
    print(f'Process pid is: {process.pid}')
    status_code = await process.wait()
    print(f'Status code: {status_code}')


asyncio.run(main())

"""
Здесь мы создаем экземпляр `Process`, чтобы запустить команду `ls` методом `create_subprocess_exec`. Можно также 
добавить после имени команды ее аргументы. В данном случае мы передаем аргумент `-l`, означающий, что нужно печатать 
дополнительную информацию, в частности о создателе файла. Создав процесс, мы печатаем его идентификатор и вызываем 
сопрограмму `wait`. Она будет ждать завершения процесса, после чего вернет код его состояния; в данном случае он 
должен быть равен нулю.
По умолчанию стандартный вывод подпроцесса соединяется каналом со стандартным выводом приложения. Заметим, что 
сопрограмма `wait` блокирует выполнение до тех пор, пока подпроцесс не завершится. Никаких гарантий касательно времени 
его работы нет, он может даже вообще не завершаться. Если зависание процесса вас беспокоит, то следует задать тайм-аут, 
вызвав сопрограмму `asyncio.wait_for`. Но тут есть подвох. Напомним, что `wait_for` завершает работающую сопрограмму по 
тайм-ауту. Если вы думаете, что при этом завершается и процесс, то вынужден вас огорчить. Завершается только задача, 
которая ждет завершения процесса, но не сам процесс.

Нужен другой способ остановить процесс по истечении тайм-аута. По счастью, в классе `Process` есть два метода, которые 
нас выручат: `terminate` и `kill`. Метод `terminate` посылает подпроцессу сигнал `SIGTERM`, 
а метод `kill` — сигнал `SIGKILL`. Отметим, что оба эти метода неблокирующие и сопрограммами не являются. 
Они просто посылают сигнал. Если вы хотите получить код состояния завершившегося подпроцесса или дождаться завершения, 
чтобы произвести какую-то очистку, то нужно еще раз вызвать `wait`.
"""